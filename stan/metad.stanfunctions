// Convert a binary number x from {0, 1} to {-1, 1}
int to_polar(int x) {
    return 2*x - 1;
}

// Calculate the probability of making a response given a stimulus
real type1_pmf(int stimulus, int response, real d_prime, real c) {
    return Phi(to_polar(response) * (to_polar(stimulus)*d_prime/2 - c));
}

// Create a K-simplex of probabilities that confidence=k
// (i.e., a K-vector [p(c=1), p(c=2), ... p(c=K)]) given:
// int K: number of possible confidence ratings
// int R: response
// int A: accuracy of response
// real meta_d_prime: type-1 sensitivity
// real c: type-1 threshold
// vector meta_c2_r: type-2 thresholds for response=r
vector type2_pmf(int response, int accuracy, real meta_d_prime,
                real meta_c, vector meta_c2_0, vector meta_c2_1) {
    int K = size(meta_c2_0) + 1;
    real mu = to_polar(accuracy) * meta_d_prime / 2;

    // set response-specific thresholds for vectorization
    vector[K+1] C2;
    if (response) {
        C2[1] = meta_c;
        C2[2:K] = meta_c2_1;
        C2[K+1] = positive_infinity();
    } else {
        C2[1] = -meta_c;
        C2[2:K] = -meta_c2_0;
        C2[K+1] = positive_infinity();
    }

    // compute response probabilities
    vector[K+1] theta = Phi(mu - C2);
    return (theta[1:K] - theta[2:(K+1)]) / theta[1];
}

// Compute the pseudo type-1 ROC given:
//  theta_1: the type-1 response probabilities
//  theta_2: the conditional type_2 response probabilities
array[,] real type1_ROC(array[] vector theta_1, array[,] vector theta_2) {
    int K = size(theta_2[1,1]);
    array[2*K-1, 2] real ROC_1;
    ROC_1[K, 1] = theta_1[1, 2];
    ROC_1[K, 2] = theta_1[2, 2];

    for (i in 2:K) {
        // pseudo type-1 FA  rate for confidence i
        // stimulus == 0 (incorrect)
        ROC_1[K-i+1, 1] = 1 - theta_1[1,1]*sum(theta_2[1, 2, i:K]);
        ROC_1[K+i-1, 1] = theta_1[1,2]*sum(theta_2[2, 1, i:K]);
        
        // pseudo type-1 hit rate for confidence i
        // stimulus == 1 (correct)
        ROC_1[K-i+1, 2] = 1 - theta_1[2,1]*sum(theta_2[1, 1, i:K]);
        ROC_1[K+i-1, 2] = theta_1[2,2]*sum(theta_2[2, 2, i:K]);
    }

    return ROC_1;
}

// Compute the type-2 ROC given:
//   theta_2: the conditional type-2 response probabilities
array[,,] real type2_ROC(array[,] vector theta_2) {
    int K = size(theta_2[1,1]);
    array[2, K-1, 2] real ROC_2;

    for (i in 1:2) {
        for (j in 2:K) {
        ROC_2[i, j-1, 1] = sum(theta_2[i, 1, j:K]);  // type-2 FA rate
        ROC_2[i, j-1, 2] = sum(theta_2[i, 2, j:K]);  // type-2 hit rate	
        }
    }
    return ROC_2;
}

// phi(x): the likelihood of the standard normal distribution
real phi(real x) {
    return exp(std_normal_lpdf(x));
}

real induced_dirichlet_response(vector alpha, int response, int accuracy,
                        real meta_d_prime, real meta_c,
                        vector meta_c2_0, vector meta_c2_1) {
    int K = size(meta_c2_0) + 1;
    // pre-compute evidence mean and type 1 response probability
    real mu = to_polar(accuracy) * meta_d_prime / 2;
    real p = Phi(to_polar(response) * (mu - meta_c));
    real r = to_polar(response);
        

    vector[K] C2;
    C2[1] = meta_c;
    if (response)
        C2[2:K] = meta_c2_1;
    else
        C2[2:K] = meta_c2_0;

    // compute induced confidence probabilities
    vector[K] p_confidence = type2_pmf(response, accuracy, meta_d_prime,
                                        meta_c, meta_c2_0, meta_c2_1);

    // compute Jacobian matrix of P(conf | meta_c2)
    matrix[K, K] J = rep_matrix(0, K, K);
    J[, 1] = rep_vector(1, K);
    for (k in 2:K) {
        J[k-1, k] = r * phi(C2[k] - mu) / p;
        J[k, k] = -r * phi(C2[k] - mu) / p;
    }

    return dirichlet_lpdf(p_confidence | alpha) +
        log_determinant(J);
}

real induced_dirichlet(vector alpha, int accuracy,
                       real meta_d_prime, real meta_c,
                       vector meta_c2_0, vector meta_c2_1) {
    return induced_dirichlet_response(alpha, 0, accuracy, meta_d_prime, meta_c, meta_c2_0, meta_c2_1) + 
        induced_dirichlet_response(alpha, 1, accuracy, meta_d_prime, meta_c, meta_c2_0, meta_c2_1);
}